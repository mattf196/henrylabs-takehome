import { readHistory, writeHistory } from '../utils/store';
import { generateTimeBasedID, genReqId, hashToString, signPayload } from '../utils/crypto';
import { INTERNAL_WEBHOOKS } from './webhooks';
import { sleep } from '../utils/async';
import { isValidCardNumber, isValidExpiry } from '../utils/card';
// checkoutId -> { historyRecordId }
const INTERNAL_CHECKOUTS = {};
export class Checkout {
    /**
     * Create a new checkout session
     * @param amount - The amount for the checkout
     * @param currency - The curreny type (note: not all are supported atm)
     * @param customerId - Optional customer ID, used for unique customer identification
     * @returns The response from the checkout creation
     */
    async create(params) {
        await sleep(Math.random() * 100);
        const hashId = await this.buildHistoryHash(params);
        const history = await readHistory();
        const sameRecords = history.filter((v) => v.id === hashId);
        // Add to history records
        await writeHistory({
            id: hashId,
            amount: params.amount,
            currency: params.currency,
            customerId: params.customerId ?? null,
        });
        // ---------------------------------------
        // Phase 1: Validation
        // ---------------------------------------
        const validationFailure = this.validateCreate(params);
        // ---------------------------------------
        // Phase 2: Business Logic
        // ---------------------------------------
        const response = validationFailure ?? (await this.processCreateDecision(params, hashId, sameRecords.length));
        // ---------------------------------------
        // Phase 3: Webhook Scheduling
        // ---------------------------------------
        this.scheduleCreateWebhook(hashId, response);
        // Simulate API latency
        await sleep(Math.random() * 2000);
        return response;
    }
    /**
     * Confirm a checkout session
     * @param params - Either embedded or raw card checkout confirmation parameters
     * @returns - The response from the checkout confirmation
     */
    async confirm(params) {
        await sleep(Math.random() * 100);
        // ---------------------------------------
        // Phase 1: Validation (no early returns)
        // ---------------------------------------
        const validationFailure = await this.validateConfirm(params);
        // ---------------------------------------
        // Phase 2: Business Logic
        // ---------------------------------------
        const response = validationFailure ?? (await this.processConfirmDecision(params));
        // ---------------------------------------
        // Phase 3: Async Webhook Emission
        // ---------------------------------------
        this.scheduleConfirmWebhook(params, response);
        // Simulate response delay
        await sleep(Math.random() * 2000);
        return response;
    }
    validateCreate(params) {
        if (params.amount <= 0) {
            return {
                _reqId: genReqId(),
                status: 'failure',
                substatus: '500-error',
                code: 500,
                message: 'Invalid amount',
            };
        }
        if (params.currency === 'JPY') {
            return {
                _reqId: genReqId(),
                status: 'failure',
                substatus: '501-not-supported',
                code: 501,
                message: 'This currency is currently not supported, please convert to another supported currency first.',
            };
        }
        // Simulated stupid internal failures
        if ((params.customerId ?? '').length === crypto.randomUUID().length || (params.customerId ?? '').includes('-') || params.customerId === '') {
            return {
                _reqId: genReqId(),
                status: 'failure',
                substatus: '500-error',
                code: 500,
                message: 'An internal error occurred when creating checkout',
            };
        }
        return null;
    }
    async processCreateDecision(params, hashId, duplicateCount) {
        const resCase = this.determineResponseCase(params.amount, duplicateCount);
        if (resCase === 'failure-retry') {
            return {
                _reqId: genReqId(),
                status: 'failure',
                substatus: '503-retry',
                code: 503,
                message: 'Server is busy, please retry the request',
            };
        }
        if (resCase === 'failure-fraud') {
            return {
                _reqId: genReqId(),
                status: 'failure',
                substatus: '502-fraud',
                code: 502,
                message: 'Potential fraud detected with this purchase',
            };
        }
        const checkoutId = await this.createCheckoutRecord(hashId);
        if (resCase === 'success-deferred') {
            return {
                _reqId: genReqId(),
                status: 'success',
                substatus: '202-deferred',
                code: 202,
                message: 'Authorizing, checkout information will likely be returned via webhook',
            };
        }
        return {
            _reqId: genReqId(),
            status: 'success',
            substatus: '201-immediate',
            code: 201,
            message: 'Approved',
            data: {
                checkoutId,
                paymentMethodOptions: ['embedded', 'raw-card'],
            },
        };
    }
    async createCheckoutRecord(hashId) {
        const checkoutId = `cki_${await generateTimeBasedID('checkout')}`;
        INTERNAL_CHECKOUTS[`${checkoutId}`] = {
            historyRecordId: hashId,
        };
        return checkoutId;
    }
    scheduleCreateWebhook(hashId, response) {
        const webhookDelay = Math.random() * 3000;
        setTimeout(async () => {
            // Deferred flow resolves later
            if (response.status === 'success' && response.substatus === '202-deferred') {
                if (Math.random() > 0.2) {
                    const checkoutId = await this.createCheckoutRecord(hashId);
                    this.sendWebhookResponse('checkout.create', {
                        _reqId: response._reqId,
                        status: 'success',
                        substatus: '201-immediate',
                        code: 201,
                        message: 'Approved',
                        data: {
                            checkoutId,
                            paymentMethodOptions: ['embedded', 'raw-card'],
                        },
                    });
                }
                else if (Math.random() > 0.05) {
                    this.sendWebhookResponse('checkout.create', {
                        _reqId: response._reqId,
                        status: 'failure',
                        substatus: '503-retry',
                        code: 503,
                        message: 'Server error, please retry the request',
                    });
                }
                else {
                    this.sendWebhookResponse('checkout.create', {
                        _reqId: response._reqId,
                        status: 'failure',
                        substatus: '502-fraud',
                        code: 502,
                        message: 'Potential fraud detected with this purchase',
                    });
                }
                return;
            }
            // Immediate success or failure
            this.sendWebhookResponse('checkout.create', response);
        }, webhookDelay);
    }
    async buildHistoryHash(params) {
        return await hashToString(JSON.stringify({
            type: 'HISTORY_RECORD',
            amount: params.amount,
            currency: params.currency,
            customerId: params.customerId,
        }));
    }
    ///
    async validateConfirm(params) {
        if (`${params.checkoutId}`.length !== 20 || !`${params.checkoutId}`.startsWith('cki_')) {
            return {
                _reqId: genReqId(),
                status: 'failure',
                substatus: '500-error',
                code: 500,
                message: 'Invalid checkout ID',
            };
        }
        if (!INTERNAL_CHECKOUTS[`${params.checkoutId}`]) {
            return {
                _reqId: genReqId(),
                status: 'failure',
                substatus: '503-retry',
                code: 504,
                message: 'Expired checkout ID',
            };
        }
        if (params.type === 'embedded') {
            if (params.data.paymentToken.length !== 20 || !params.data.paymentToken.startsWith('pmt_')) {
                return {
                    _reqId: genReqId(),
                    status: 'failure',
                    substatus: '500-error',
                    code: 500,
                    message: 'Invalid payment token',
                };
            }
        }
        if (params.type === 'embedded') {
            const paymentToken = `pmt_${await generateTimeBasedID('payment-token')}`;
            if (params.data.paymentToken !== paymentToken) {
                return {
                    _reqId: genReqId(),
                    status: 'failure',
                    substatus: '503-retry',
                    code: 503,
                    message: 'Expired payment token',
                };
            }
        }
        if (params.type === 'raw-card') {
            const { number, expMonth, expYear, cvc } = params.data;
            if (!isValidCardNumber(number)) {
                return {
                    _reqId: genReqId(),
                    status: 'failure',
                    substatus: '500-error',
                    code: 500,
                    message: 'Invalid card number',
                };
            }
            if (!isValidExpiry(expMonth, expYear)) {
                return {
                    _reqId: genReqId(),
                    status: 'failure',
                    substatus: '500-error',
                    code: 500,
                    message: 'Card expired',
                };
            }
            if (!/^\d{3,4}$/.test(cvc)) {
                return {
                    _reqId: genReqId(),
                    status: 'failure',
                    substatus: '500-error',
                    code: 500,
                    message: 'Invalid CVC',
                };
            }
        }
        return null;
    }
    async processConfirmDecision(params) {
        const decision = Math.random();
        if (decision > 0.95) {
            return {
                _reqId: genReqId(),
                status: 'failure',
                substatus: '502-fraud',
                code: 502,
                message: 'Potential fraud detected with this purchase',
            };
        }
        if (decision > 0.65) {
            return {
                _reqId: genReqId(),
                status: 'failure',
                substatus: '503-retry',
                code: 503,
                message: 'Server is busy, please retry the request',
            };
        }
        if (decision > 0.35) {
            return {
                _reqId: genReqId(),
                status: 'success',
                substatus: '202-deferred',
                code: 202,
                message: 'Authorizing, purchase information will likely be returned via webhook',
            };
        }
        return this.buildInstantConfirmSuccess(params.checkoutId);
    }
    async buildInstantConfirmSuccess(checkoutId) {
        const { historyRecordId } = INTERNAL_CHECKOUTS[`${checkoutId}`] ?? {};
        if (!historyRecordId) {
            return {
                _reqId: genReqId(),
                status: 'failure',
                substatus: '500-error',
                code: 500,
                message: 'Missing history record',
            };
        }
        const history = await readHistory();
        const record = history.find((v) => v.id === historyRecordId);
        if (!record) {
            return {
                _reqId: genReqId(),
                status: 'failure',
                substatus: '500-error',
                code: 500,
                message: 'Missing history record',
            };
        }
        const confirmationId = 'cof_' +
            (await hashToString(JSON.stringify({
                type: 'CONFIRMATION_ID',
                amount: record.amount,
                currency: record.currency,
                customerId: record.customerId,
            })));
        return {
            _reqId: genReqId(),
            status: 'success',
            substatus: '201-immediate',
            code: 201,
            message: 'Approved',
            data: {
                confirmationId,
                amount: record.amount,
                currency: record.currency,
                customerId: record.customerId ?? undefined,
            },
        };
    }
    scheduleConfirmWebhook(params, response) {
        const webhookDelay = Math.random() * 3000;
        setTimeout(() => {
            if (response.status === 'success' && response.substatus === '202-deferred') {
                if (Math.random() > 0.2) {
                    this.buildInstantConfirmSuccess(params.checkoutId).then((finalResponse) => {
                        this.sendWebhookResponse('checkout.confirm', finalResponse);
                    });
                }
                else if (Math.random() > 0.05) {
                    this.sendWebhookResponse('checkout.confirm', {
                        _reqId: response._reqId,
                        status: 'failure',
                        substatus: '503-retry',
                        code: 503,
                        message: 'Server error, please retry the request',
                    });
                }
                else {
                    this.sendWebhookResponse('checkout.confirm', {
                        _reqId: response._reqId,
                        status: 'failure',
                        substatus: '502-fraud',
                        code: 502,
                        message: 'Potential fraud detected with this purchase',
                    });
                }
                return;
            }
            this.sendWebhookResponse('checkout.confirm', response);
        }, webhookDelay);
    }
    //
    determineResponseCase(amount, sameRecords) {
        // --- Base probabilities ---
        let immediateWeight = 65;
        let deferredWeight = 20;
        let retryWeight = 10;
        let fraudWeight = 0;
        // --- Adjust based on repeated attempts ---
        immediateWeight -= sameRecords * 10;
        deferredWeight += sameRecords * 5;
        retryWeight += sameRecords * 5;
        fraudWeight += sameRecords * 15;
        // --- Adjust based on amount ---
        if (amount > 1000) {
            deferredWeight += sameRecords * 5 + 10;
            retryWeight += sameRecords * 5 + 10;
        }
        if (amount > 5000) {
            immediateWeight -= sameRecords * 5 + 15;
            retryWeight += sameRecords * 5 + 30;
            fraudWeight += sameRecords * 10;
        }
        if (amount > 10000) {
            fraudWeight += sameRecords * 30;
        }
        // Ensure no negative weights
        immediateWeight = Math.max(0, immediateWeight);
        deferredWeight = Math.max(0, deferredWeight);
        retryWeight = Math.max(0, retryWeight);
        fraudWeight = Math.max(0, fraudWeight);
        // --- Weighted random selection ---
        const total = immediateWeight + deferredWeight + retryWeight + fraudWeight;
        const rand = Math.random() * total;
        if (rand < immediateWeight) {
            return 'success-immediate';
        }
        if (rand < immediateWeight + deferredWeight) {
            return 'success-deferred';
        }
        if (rand < immediateWeight + deferredWeight + retryWeight) {
            return 'failure-retry';
        }
        return 'failure-fraud';
    }
    async sendWebhookResponse(baseType, response) {
        const statusSuffix = response.status === 'success' ? 'success' : 'failure';
        const eventType = `${baseType}.${statusSuffix}`;
        // Build all matching event types hierarchically
        const matchingTypes = ['checkout', baseType, eventType];
        const hooks = INTERNAL_WEBHOOKS.filter((w) => matchingTypes.includes(w.event));
        const event = {
            uid: `_${genReqId()}_`,
            type: eventType,
            createdAt: Date.now(),
            data: response,
        };
        const payload = JSON.stringify(event);
        await Promise.allSettled(hooks.map(async (hook) => {
            const headers = {
                'Content-Type': 'application/json',
            };
            if (hook.secret) {
                headers['x-henry-signature'] = signPayload(payload, hook.secret);
            }
            await fetch(hook.url, {
                method: 'POST',
                headers,
                body: payload,
            });
        }));
        return true;
    }
}
